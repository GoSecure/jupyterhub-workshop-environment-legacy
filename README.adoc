= README

== Setup Instructions

=== Prepare for Deployment

These steps should be done locally before provisioning the JupterHub
server to facilitate deployment.

==== Setup GitHub Authentication

Create a GitHub application reflecting the purpose of your JupyterHub
workshop. It will be used to allow users to login and gain access to
the workshop servers. You should know the following information ahead
of time:

* Workshop Name (Application Name)
* Workshop Server URL (Doesn't need to resolve yet)
* Workshop Description
* Workshop Icon if desired.

Follow the instructions under the *Authenticator setup* section of
`README.upstream.md` and create `secrets/oauth.env` with the following
content:

  GITHUB_CLIENT_ID=<github_client_id>
  GITHUB_CLIENT_SECRET=<github_client_secret>
  OAUTH_CALLBACK_URL=https://<myhost.mydomain>/hub/oauth_callback

*NOTE*: Applications for workshops should be created under the GoSecure organization at
https://github.com/organizations/GoSecure/settings/applications/new

Ask organisation admin to create the application with the required information.

By default our setup is open to anyone to create an account like for an open
workshop with no pre-registrations (different options available below). Setup
the users with admin privileges in advance by writing the github usernames to
the `secrets/admins` file (one per line).

==== Setup Administrator Accounts

Add one or more accounts in `secrets/admins`. These accounts will be
granted full access to the Jupyter Notebook.


==== Workshop Files: Overlay Filesystem

There are two ways to expose files to the workshop attendees.

.Read-only shared with all participants

All users will have access to a directory in their own homes (`/home/jovyan/`)
called `workshop/` that will be mapped to the servers' `/srv/workshop/` via a
docker volume.

Changes made in `/srv/workshop/*` will be reflected instantly for all participants.


.Files for participants (writable and executable)

On container creation, a directory called `labs/` will be created and
populated from the servers' `/srv/workshop/labs-source/` content.

This will happen only once per user. If you need to re-populate it, you need
to delete the user' files in his volume. These are visible under:
`/var/lib/docker/volumes/jupyterhub-user-<username>/_data/`

=== Deploying the Server

Ensure that you have a recent version of Terraform installed and get it ready:

    terraform init

Configure your Digital Ocean credentials and other settings in `terraform.tfvars`:

    # the following values are used as tags in digital ocean so only lowercase, dash and underscore allowed
    workshop_name = "<workshop-name>"
    tag_owner = "<username>"
    tag_event = "<event-name>"
    do_token = "<your DO token>"
    # default is small 1 CPU and 2GB RAM
    #instance_size = "c-4"

Spawn and provision the droplet. It might take a while to setup and
provision, so be patient. The repository should be synchronized to
`/srv`

    terraform validate
    terraform plan
    terraform apply


=== Server-Side Configuration

To connect to the server via SSH, run:

    ./bin/ssh-connect.sh


==== Build Notebook Image

If you are using a custom notebook, you need to build it first and rebuild
the jupyterhub-user image. The base image that jupyterhub-user will
use is configured with the `DOCKER_NOTEBOOK_IMAGE` key in `.env`.

  cd examples/custom-notebook-server/
  # <change what you need or use another example>
  docker build -t workshop-notebook .
  cd ../../
  make notebook_image

==== Configure TLS and HTTPS with Certbot

* Ensure that your domain name resolves to the created droplet public address.
* Create certificates using certbot (make sure docker-compose is not running)

    certbot certonly --standalone -d <domain-name>
    cp /etc/letsencrypt/live/<domain-name>/fullchain.pem secrets/jupyterhub.crt
    cp /etc/letsencrypt/live/<domain-name>/privkey.pem secrets/jupyterhub.key


==== Launch the Notebook Server

After everything is configured, you can spawn the notebook server with the following commands:

      cd /srv/jupyterhub/
      make
      docker-compose up

Whenever changing the secrets or environment variables, rebuilding and
relaunching the images is required:

    docker-compose down
    make
    docker-compose up

== Optional: Only allow specific users

If you create a `secrets/users` file with a list of allowed GitHub usernames,
only these usernames will be able to sign-up to the server.

When you change that list, you need to restart the JupyterHub container.
Easiest way to achieve this is to kill the docker-compose environment, 
run `make` and restart docker-compose.

    <ctrl-d>
    make
    docker-compose up

User lists can optionally have an `admin` tag to identify admin users. Ex:

    linus admin
    obilodeau
    masarah admin


== Optional: Stop Open Registrations

// TODO


== Optional: User Instances Exposed to the Internet

Uncomment the following line in the `.env` file and make sure to rebuild the
`hub` container.

    DOCKER_NOTEBOOK_EXPOSE_NETWORK=true

Please double check that `secrets/context.env` has the correct `HOST_IP` in it.
The Makefile is a little bit brittle in that regard.


== Operational Procedures

=== Add a user to a running instance

Add GitHub username to `secrets/users`. Restart the jupyterhub with:

    docker-compose up -d --build hub


== Debugging

=== Logging

In `jupyter_config.py`, setting `log_level` to `'DEBUG'` will give more information in the docker-compose logs:

    c.JupyterHub.log_level = 'DEBUG'


=== Troubleshooting User Container Failure

If you get strange errors when the user container tries to start, make sure that it can start properly.
Errors can be as obscure as: "traitlets.traitlets.TraitError: The 'ip' trait of a Server instance must be a unicode string, but a value of None <class 'NoneType'> was specified".
Disable the container removal and inspect the failed container logs with the following steps:

* Disable container removal by making sure that the DockerSpawner is configured properly.
  In `jupyter_config.py` ensure that this configuration is present (and not overridden after):

    c.DockerSpawner.remove = False

* Load the new config:

    docker-compose down
    make
    docker-compose up

* Upon container creation failure now you can see the containers being left dangling:

    docker ps
    docker logs jupyter-obilodeau